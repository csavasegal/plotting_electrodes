function data_all = concatBlocks_Multisubj_Clara_tmp(sbj_names, project_name, block_names,dirs,T3,freq_band,datatype,concatfields,tag)
% modified ConcatBlocks function to loop across multiple subjects without
% making any other change
% this function concatenates data (either spectral or single timecourse) across blocks for a single electrode
%% INPUTS:
%       sbj_name: subject name
%       T3 is the electrode that you want to be read in 
%       block_names: blocks to be analyed (cell of strings)
%       dirs: directories pointing to files of interest (generated by InitializeDirs)
%       el: electrode number
%       datatype: 'CAR','HFB',or 'Spec'
%       concatfields: cell of field(s) in data to concatenate (e.g.
%                     'phase', 'wave') in addition to trialinfo
%       tag: tag in filename between data type and block name, specifying which type of data to load (e.g. 'stimlock_bl_corr')
%       concatParams.run_blc: true or false (whether to run baseline correction)
%                   .bl_win: time window (in sec) to use for baseline
%                   .power: true or false

%%

%getting the electrode below as el using T3

for i = 1:length(concatfields)
    data_all.(concatfields{i}) = [];
end

data_all.trialinfo = [];
% block_names_table = table;
% for sb = 1:length(sbj_names)
%     sbj_name = sbj_names{sb};
%     block_names = BlockBySubj(sbj_names{i},project_name);
%     %dirs = InitializeDirs(project_name, sbj_name, comp_root, server_root,code_root);
%     T3.anat{sb}
%     %need to be able to load multiple subjects and block-names
%     block_names_table.block_names(sb) = block_names
%     block_names_table.sbj_name{sb} = sbj_names{sb}
%     block_names_table.el{sb} = T3.anat{sb}
% end 

for sb = 1:length(sbj_names)
    sbj_name = sbj_names{sb};
    block_names = BlockBySubj(sbj_names{i},project_name);
    
    for j = 1:length(T3.anat{sb})
        el = T3.anat{sb}(j);
        for bi = 1:length(block_names)
            bn = block_names{bi};
            dir_in = [dirs.data_root,filesep,datatype,'Data',filesep,freq_band,filesep,sbj_name,filesep,bn,filesep,'EpochData'];
            load(sprintf('%s/%siEEG_%s_%s_%.2d.mat',dir_in,freq_band,tag,bn,el));
            %load('/Volumes/CSS_backup/data/neuralData/BandData/HFB/C18_37/RACE_1/EpochData/HFBiEEG_stimlock_bl_corr_RACE_1_176.mat')
            
            %% Specifics of each project
            % Complement or fix ttrialinfo
            data.trialinfo = CompTrialinfo(data.trialinfo, project_name);
            data.trialinfo.block = cell(height(data.trialinfo),1);
            data.trialinfo.block(:) = {bn}; % keep track of which trials coming from which block
            data.trialinfo.sbj = cell(height(data.trialinfo),1);
            data.trialinfo.sbj(:) = {sbj_names{sb}}; %keep track of which subject
            data.trialinfo.el(:) = el;
            
            % concatenante EEG data across blocks
            for i = 1:length(concatfields)
                if strcmp(datatype,'Spec')
                    data_all.(concatfields{i}) = cat(2,data_all.(concatfields{i}),data.(concatfields{i}));
                else
                    data_all.(concatfields{i}) = cat(1,data_all.(concatfields{i}),data.(concatfields{i}));
                end
            end
            
            % concatenate trial info across blocks
            % concatenate trial info across blocks
            if sum(strcmp(data.trialinfo.Properties.VariableNames, 'allstimdur')) > 0
                data.trialinfo.allstimdur = [];
            else
            end
            data_all.trialinfo = [data_all.trialinfo; data.trialinfo];
            if sum(strcmp(data_all.trialinfo.Properties.VariableNames, 'allstimdur')) > 0
                data_all.trialinfo.allstimdur = [];
            else
            end
            
            
        end
    end
end


% add all additional info back to concatenated data structure (e.g. channame, time, freq)
allfields = setdiff(fieldnames(data),{'wave','phase','trialinfo'});
for fi = 1:length(allfields)
    data_all.(allfields{fi})=data.(allfields{fi});
end